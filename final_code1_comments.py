# -*- coding: utf-8 -*-
"""Final Code1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JmmD20lZ5QOPw_ty_WAois5cf6Jh0Htz
"""

#Things to Import

import streamlit as st
import os
import pickle
from datetime import datetime
import requests
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from matplotlib import ticker
import io


#File Paths
USER_DATA_FILE = "users_data.pkl"
FINANCE_DATA_FILE = "data.pkl"

#API --> Currency
@st.cache_data
def get_supported_currencies():
    fallback_currencies = {
        "USD": "United States Dollar",
        "EUR": "Euro",
        "GBP": "British Pound Sterling",
        "JPY": "Japanese Yen",
        "CHF": "Swiss Franc",
        "CAD": "Canadian Dollar",
        "AUD": "Australian Dollar",
        "CNY": "Chinese Yuan",
        "INR": "Indian Rupee",
        "BRL": "Brazilian Real",
        "MXN": "Mexican Peso",
        "ZAR": "South African Rand",
        "SGD": "Singapore Dollar",
        "KRW": "South Korean Won"
    }

    api_key = "89d37f1167b75125f76019f34e3d1811"  # Key
    url = "https://api.currencylayer.com/list"
    params = {
        "access_key": api_key
    }

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        data = response.json()

        if data.get("success"):
            currencies = data["currencies"]
            return currencies
        else:
            st.error("‚ö†Ô∏è API returned an error: " + data.get("error", {}).get("info", "Unknown error"))
            return fallback_currencies

    except requests.exceptions.RequestException as e:
        st.error(f"‚ö†Ô∏è Error fetching currency data: {e}")
        return fallback_currencies

# Use the function to get currencies
currencies = get_supported_currencies()

# Load data from files ‚Äî do this BEFORE any session logic - a very important step
def load_data():
    if os.path.exists(USER_DATA_FILE):
        with open(USER_DATA_FILE, 'rb') as file:
            st.session_state.users = pickle.load(file)
    if os.path.exists(FINANCE_DATA_FILE):
        with open(FINANCE_DATA_FILE, 'rb') as file:
            st.session_state.data = pickle.load(file)

load_data()

# Initialize session state
if 'username' not in st.session_state:
    st.session_state.username = None
if 'users' not in st.session_state:
    st.session_state.users = {}
if 'data' not in st.session_state:
    st.session_state.data = {}

# Load data from files
def load_data():
    if os.path.exists(USER_DATA_FILE):
        with open(USER_DATA_FILE, 'rb') as file:
            st.session_state.users = pickle.load(file)
    if os.path.exists(FINANCE_DATA_FILE):
        with open(FINANCE_DATA_FILE, 'rb') as file:
            st.session_state.data = pickle.load(file)

# Save data to files
def save_data():
    with open(USER_DATA_FILE, 'wb') as file:
        pickle.dump(st.session_state.users, file)
    with open(FINANCE_DATA_FILE, 'wb') as file:
        pickle.dump(st.session_state.data, file)

# Account creation with password
def create_account():
    st.subheader("Create Account")

    st.markdown("### Welcome to Budget Friend! üí∏")
    st.markdown("**Start your financial journey today! You're one step closer to mastering your budget. üí™**")

    username = st.text_input("Choose a username", key="create_username")
    password = st.text_input("Choose a password", type="password", key="create_password")

    if st.button("Create Account"):
        if username in st.session_state.users:
            st.warning("Username already exists.")
        elif username and password:
            st.session_state.users[username] = password
            st.session_state.data[username] = {"currency": "EUR"}  # Default currency on account creation
            st.session_state.username = username
            st.session_state.currency = "EUR"  # Also set in session
            save_data()
            st.success("Account created and logged in.")
            dashboard()  # Redirect to dashboard after account creation
        else:
            st.error("Please provide both username and password.")


# Login with password
def login():
    st.subheader("Login")

    st.markdown("### Welcome to Budget Friend! üí∏")
    st.markdown("**You're doing great! Let's keep those finances on track. üí™**")

    username = st.text_input("Enter your username", key="login_username")
    password = st.text_input("Enter your password", type="password", key="login_password")

    if st.button("Login"):
        if username in st.session_state.users and st.session_state.users[username] == password:
            st.session_state.username = username
            load_data()

            # Ensure user data exists
            if username not in st.session_state.data:
                st.session_state.data[username] = {}

            user_data = st.session_state.data[username]

            # Load saved currency or default to EUR
            st.session_state.currency = user_data.get("currency", "EUR")

            st.success(f"Welcome back, {username}!")
            dashboard()
        else:
            st.error("Invalid username or password.")


# Definition of INCOME, MONTH AND EXPENSES
income_sources = ["Salary","Bonus", "Freelance","Investment", "Other Income"]
months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
# these include now more expenses to be able to fit to everyone
expense_categories = ["Food", "Transport", "Rent", "Utilities", "Entertainment", "Groceries", "Health & Fitness", "Subscriptions", "Dining Out", "Education", "Shopping", "Travel", "Insurance", "Pets", "Childcare","Debt Payments", "Other Expenses"]

# Choce the month and year handle the month and year
def choose_time():
    st.subheader("Choose the Month and Year")

    # Month selection with validation
    current_month = st.selectbox("Select the month", months)

    # Year input with validation
    current_year = st.text_input("Enter the year (e.g. 2025): ")

    # Validate the year input
    if current_year:
        if current_year.isdigit() and len(current_year) == 4:
            st.success(f"‚úî Valid year entered: {current_year}")
        else:
            st.error("‚úò Please enter a valid year (e.g. 2025).")
            return None
    else:
        return None

    # Generate the key for the dictionary (no spaces in the key)
    key = f"{current_month}_{current_year}"
    key = key.replace(" ", "")  # Remove spaces if any

    # Store the key in session_state and initialize data for that key
    if "data" not in st.session_state:
        st.session_state.data = {}

    if key not in st.session_state.data:
        st.session_state.data[key] = {}

    st.success(f"‚úÖ New month and year defined for {key.replace('_', ' ')}.")
    return key

#DEFINE BUDGET FUNCTION
def define_budget():
    st.subheader("üìÖ Define your monthly Budget")

    key = choose_time()

    # Only continue if a valid key is returned
    if key:
        st.markdown("---")
        st.subheader("üìä Define Your Budget")
        budget_type = st.radio("What would you like to manage?", ["Expected Income", "Expected Expenses"])

        # Initialize budget inputs if not already in session state
        if "budget_inputs" not in st.session_state:
            st.session_state.budget_inputs = {}

        if budget_type == "Expected Expenses":
            manage_expense_budget(key)
        elif budget_type == "Expected Income":
            manage_budget_for_category(key)


def manage_budget_for_category(key):
    if st.session_state.username not in st.session_state.data:
        st.session_state.data[st.session_state.username] = {}

    user_data = st.session_state.data[st.session_state.username]
    if key not in user_data:
        user_data[key] = {}

    st.subheader("üíº Manage Income Budget")
    selected_source = st.selectbox("Select income source", income_sources)
    action = st.radio("Choose action", ["Add", "Edit", "Delete"])
    field = f"expected_{selected_source.lower()}"

    currency = st.session_state.get("currency", "EUR")
    data_changed = False

    if action == "Add":
        amount = st.number_input("Enter budget amount:", min_value=0.0, format="%.2f")

        if st.button("‚ûï Add Income Budget"):
            current_value = user_data[key].get(field)

            if selected_source == "Other Income":
                if isinstance(current_value, dict):
                    existing_amount = current_value.get("amount", 0.0)
                else:
                    existing_amount = current_value if isinstance(current_value, (int, float)) else 0.0

                user_data[key][field] = {
                    "amount": existing_amount + amount,
                    "description": ""  # Removed description input and kept empty
                }
            else:
                existing_amount = current_value if isinstance(current_value, (int, float)) else 0.0
                user_data[key][field] = existing_amount + amount

            st.success(f"‚úî Added {amount} {currency} under {selected_source} Income Budget!")
            data_changed = True

    elif action == "Edit":
        if field in user_data[key]:
            current_value = user_data[key][field]
            if selected_source == "Other Income" and isinstance(current_value, dict):
                amount = current_value.get("amount", 0.0)
                new_amount = st.number_input("New budget amount:", value=amount)

                if st.button("‚úèÔ∏è Update Budget"):
                    user_data[key][field] = {
                        "amount": new_amount,
                        "description": ""  # Removed description input
                    }
                    st.success("‚úî Budget updated!")
                    data_changed = True
            else:
                current_amount = current_value if isinstance(current_value, (int, float)) else 0.0
                new_amount = st.number_input("New budget amount:", value=current_amount)
                if st.button("‚úèÔ∏è Update Budget"):
                    user_data[key][field] = new_amount
                    st.success("‚úî Budget updated!")
                    data_changed = True
        else:
            st.warning("‚ö† No existing budget for this category.")

    elif action == "Delete":
        if field in user_data[key]:
            if st.button("üóë Delete Budget"):
                del user_data[key][field]
                st.success("‚úî Budget deleted.")
                data_changed = True
        else:
            st.warning("‚ö† No budget found to delete.")

    if data_changed:
        save_data()

    st.markdown("---")
    st.subheader("üìä Income Budget Summary")
    if key in user_data:
        entries = []
        total_income = 0.0
        for source in income_sources:
            field_key = f"expected_{source.lower()}"
            value = user_data[key].get(field_key)

            if value:
                if source == "Other Income" and isinstance(value, dict):
                    amount = value['amount']
                    entries.append(f"‚Ä¢ **{source}**: {amount:.2f} {currency}")
                else:
                    amount = value
                    entries.append(f"‚Ä¢ **{source}**: {amount:.2f} {currency}")
                total_income += amount

        if entries:
            for entry in entries:
                st.markdown(entry)
            st.subheader(f"**Total Budgted Income**: {total_income:.2f} {currency}")
        else:
            st.info("No income budget entries for this period yet.")
    else:
        st.info("No data for the selected month and year.")


def manage_expense_budget(key):
    if st.session_state.username not in st.session_state.data:
        st.session_state.data[st.session_state.username] = {}

    user_data = st.session_state.data[st.session_state.username]
    if key not in user_data:
        user_data[key] = {}

    st.subheader("üì¶ Manage Expense Budget")
    selected_category = st.selectbox("Select expense category", expense_categories)
    action = st.radio("Choose action", ["Add", "Edit", "Delete"])

    field = f"expected_{selected_category.lower()}"
    currency = st.session_state.get("currency", "EUR")
    data_changed = False

    if action == "Add":
        amount = st.number_input("Enter budgeted expense:", min_value=0.0, format="%.2f")

        if st.button("‚ûï Add Expense Budget"):
            current_value = user_data[key].get(field)
            if selected_category == "Other Expenses":
                if isinstance(current_value, dict):
                    existing_amount = current_value.get("amount", 0.0)
                else:
                    existing_amount = current_value if isinstance(current_value, (int, float)) else 0.0

                user_data[key][field] = {
                    "amount": existing_amount + amount,
                    "description": ""  # Removed description input
                }
            else:
                existing_amount = current_value if isinstance(current_value, (int, float)) else 0.0
                user_data[key][field] = existing_amount + amount

            st.success(f"‚úî Added {amount} {currency} under {selected_category} expense budget.")
            data_changed = True

    elif action == "Edit":
        if field in user_data[key]:
            current_value = user_data[key][field]
            if selected_category == "Other Expenses" and isinstance(current_value, dict):
                current_amount = current_value.get("amount", 0.0)
                new_amount = st.number_input("New budgeted amount:", value=current_amount)

                if st.button("‚úèÔ∏è Update Expense Budget"):
                    user_data[key][field] = {
                        "amount": new_amount,
                        "description": ""  # Removed description input
                    }
                    st.success("‚úî Expense budget updated.")
                    data_changed = True
            else:
                current_amount = current_value if isinstance(current_value, (int, float)) else 0.0
                new_amount = st.number_input("New budgeted amount:", value=current_amount)
                if st.button("‚úèÔ∏è Update Expense Budget"):
                    user_data[key][field] = new_amount
                    st.success("‚úî Expense budget updated.")
                    data_changed = True
        else:
            st.warning("‚ö† No budget to edit.")

    elif action == "Delete":
        if field in user_data[key]:
            if st.button("üóë Delete Expense Budget"):
                del user_data[key][field]
                st.success("‚úî Expense budget deleted.")
                data_changed = True
        else:
            st.warning("‚ö† No budget found to delete.")

    if data_changed:
        save_data()

    st.markdown("---")
    st.subheader("üìä Expense Budget Summary")
    if key in user_data:
        entries = []
        total_expenses = 0.0
        for category in expense_categories:
            field_key = f"expected_{category.lower()}"
            value = user_data[key].get(field_key)

            if value:
                if category == "Other Expenses" and isinstance(value, dict):
                    amount = value['amount']
                    entries.append(f"‚Ä¢ **{category}**: {amount:.2f} {currency}")
                else:
                    amount = value
                    entries.append(f"‚Ä¢ **{category}**: {amount:.2f} {currency}")
                total_expenses += amount

        if entries:
            for entry in entries:
                st.markdown(entry)
            st.subheader(f"**Total Budgeted Expenses**: {total_expenses:.2f} {currency}")
        else:
            st.info("No expense budget entries for this period yet.")
    else:
        st.info("No data for the selected month and year.")


def add_income():
    st.subheader("üí∞ Register Income")
    st.markdown(
        "Use this section to manage your income sources for the selected month and year. "
        "You can add new income entries, update existing ones, or remove them. "
        "All changes are automatically saved.\nIn the end you have the possibility to check your Income Summary"
    )

    key = choose_time()
    if key is None:
        return

    if st.session_state.username not in st.session_state.data:
        st.session_state.data[st.session_state.username] = {}

    user_data = st.session_state.data[st.session_state.username]
    if key not in user_data:
        user_data[key] = {}

    col1, col2 = st.columns(2)
    with col1:
        selected_source = st.selectbox("üí∞ Income source", income_sources)
    with col2:
        action = st.radio("‚öôÔ∏è Action", ["Add", "Edit", "Delete"], horizontal=True)

    currency = st.session_state.get("currency", "EUR")

    if action == "Add":
        amount = st.number_input(f"Amount for {selected_source}", min_value=0.0, format="%.2f")

        if st.button("‚ûï Add Income", type="primary"):
            if selected_source == "Other Income":
                if selected_source in user_data[key]:
                    user_data[key][

#VIEW SUMMARY
def view_summary():
    st.subheader("üìã View Summary")
    #introsctions for the user 
    st.text("On this page, you can view detailed summaries of your spending habits and income sources for either one month or a two-month comparison.")
    st.text("First, choose whether you'd like to see a summary for a single month or compare two months." \
    "Then, select the type of summary report you want to view.")
    
    #multiple choice for the user 
    choice = st.radio("Choose an option:", ["View summary for a single month", "Compare two months over time"])
    if choice == "View summary for a single month":
        view_single_month_summary()
    elif choice == "Compare two months over time":
        compare_multiple_months()

#menu of one month summary
def view_single_month_summary():
    # Check if data exists for the user
    if st.session_state.username not in st.session_state.data or not st.session_state.data[st.session_state.username]:
        st.warning("‚ö†Ô∏è No data available. Please add some transactions first.")
        return
    #acess the data of teh user
    user_data = st.session_state.data[st.session_state.username]
    #avai√ßabel months of the user - certifuing is a two part (to avoid appearing currency)
    available_keys = [
    k for k in user_data.keys()
    if isinstance(k, str) and "_" in k and k.split("_")[-1].isdigit() and len(k.split("_")) == 2
    ]
    # Convert month keys to natural format withouth _
    month_options = [str(k).replace('_', ' ').title() for k in available_keys]

    #suser selction box of months
    selected_month = st.selectbox("üìÜ Select a month to view transactions:", [""] + month_options)
    # Avoid crashing when no valid selection is made
    if selected_month == "":
        return  
    #store temporarly the month slecetd
    month = available_keys[month_options.index(selected_month)]

    #second menu for summary type 
    select_summary = st.selectbox("üìä Select a summary:", ["Income Summary","Expense Summary", "Profit Summary", "Actual vs Expectations Graphs"])

    if select_summary == "Income Summary":
        compare_income(month, user_data)
    elif select_summary == "Expense Summary":
        compare_expenses(month,user_data)
    elif select_summary == "Profit Summary":
        compare_total_income_expenses(month, user_data)
    else:
        plot_income_vs_budget(month, user_data)
        plot_expenses_vs_budget(month, user_data)

#  summary of expenses: comaprision between budgedt and real income 
def compare_income(month, user_data):
    st.subheader(f"üìä Income Summary for {month.replace('_', ' ').title()}:\n")
    
    table_data = []
    currency = st.session_state.get("currency", "EUR")

    #loop thorugh each income source
    for source in income_sources:
        #pstore teh value of budgeted and real income inputs
        actual_entry = user_data[month].get(source, 0)
        expected_entry = user_data[month].get(f"expected_{source.lower()}", 0.0)

        # handle budgeted and real income if it's a dictionary ("Other Income")
        actual_amount = actual_entry.get("amount", 0.0) if isinstance(actual_entry, dict) else actual_entry
        expected_amount = expected_entry.get("amount", 0.0) if isinstance(expected_entry, dict) else expected_entry

        diff = actual_amount - expected_amount
        
        #messages for teh user
        if expected_amount > 0:
            if actual_amount >= expected_amount:
                status = f"‚úÖ Over by {diff:.2f} {currency}"
            else:
                status = f"‚ùå Under by {-diff:.2f} {currency}"
        else:
            status = "‚ö†Ô∏è No expected income"
        
        #table of the data 
        table_data.append({
            "Source": source,
            f"Expected ({currency})": f"{expected_amount:.2f}",
            f"Actual ({currency})": f"{actual_amount:.2f}",
            "Achieved": status
        })
    #presentation of data
    df = pd.DataFrame(table_data)
    st.write("### üí∞ Income Overview")
    st.dataframe(df, use_container_width=True)

#  summary of expenses: comaprision between budgedt and real expenes
def compare_expenses(month, user_data):
    st.subheader(f"üìä Expense Summary for {month.replace('_', ' ').title()}:\n")

    table_data = []
    currency = st.session_state.get("currency", "EUR")

    #loop through each category
    for category in expense_categories:
        actual_entry = user_data[month].get(category, 0)
        expected_entry = user_data[month].get(f"expected_{category.lower()}", 0.0)

        # handle actual and budgetd amount ("Other Expenses")
        actual_amount = actual_entry.get("amount", 0.0) if isinstance(actual_entry, dict) else actual_entry

        if isinstance(expected_entry, dict):
            expected_amount = expected_entry.get("amount", 0.0)
        else:
            expected_amount = expected_entry

        #message of to teh user 
        if expected_amount > 0:
            percentage = (actual_amount / expected_amount) * 100
            diff = actual_amount - expected_amount

            if percentage >= 100:
                status = f"‚ùå Over by {diff:.2f} {currency}"
            elif percentage >= 80:
                status = f"‚ö†Ô∏è {percentage:.1f}% used"
            else:
                status = "‚úÖ Good job!"
        else:
            status = "‚ö†Ô∏è No expected budget"

        #table of all info
        table_data.append({
            "Expense": category,
            f"Expected ({currency})": f"{expected_amount:.2f}",
            f"Actual ({currency})": f"{actual_amount:.2f}",
            "Achieved": status
        })
    #presentation of table
    df = pd.DataFrame(table_data)
    st.write("### üí∏ Expenses Overview")
    st.dataframe(df, use_container_width=True)

#csumamry of net income and profits
def compare_total_income_expenses(month, user_data):
    st.subheader("üíº Overall Summary")

    #verify there is data for the user 
    if month not in user_data:
        st.warning("‚ö†Ô∏è No data available for this month.")
        return

    income_total = 0
    expense_total = 0
    currency = st.session_state.get("currency", "EUR")

    #get the value of each income source 
    for source in income_sources:
        val = user_data[month].get(source, 0)
        income_total += val.get("amount", 0.0) if isinstance(val, dict) else val

    #get the value of each expense source
    for category in expense_categories:
        val = user_data[month].get(category, 0)
        expense_total += val.get("amount", 0.0) if isinstance(val, dict) else val

    net = income_total - expense_total

    #final summary
    st.write(f"‚ûï **Total Income:** {income_total:.2f} {currency}")
    st.write(f"‚ûñ **Total Expenses:** {expense_total:.2f} {currency}")
    st.write(f"üìâ **Net:** {net:.2f} {currency} ({'üü¢ Surplus' if net >= 0 else 'üî¥ Deficit'})")

    # final graph
    fig, ax = plt.subplots(figsize=(3.5,2))
    ax.bar(["Income", "Expenses"], [income_total, expense_total], width=0.3, color=['#4CAF50', '#F44336'])  # Narrower bars
    ax.set_title("Income vs Expenses", fontsize=7)
    ax.set_ylabel(f"Amount ({currency})", fontsize=5)
    ax.tick_params(axis='both', labelsize=5)
    ax.grid(axis='y', linestyle='--', alpha=0.3)
    fig.tight_layout(pad=0.5)
    st.pyplot(fig)

#compare real and budgetd income values 
def plot_income_vs_budget(month, user_data):
    st.subheader(f"üíº Real Income vs Budget Income - {month.replace('_', ' ').title()}")

    #check if tehre is data for the month
    if month not in user_data:
        st.warning("‚ö†Ô∏è No data available for this month.")
        return

    sources = income_sources
    actual_income = []
    expected_income = []
    display_sources = []
    currency = st.session_state.get("currency", "EUR")

    # loop through the sources and get the real and expected values 
    for source in sources:
        val = user_data[month].get(source, 0)
        amount = val.get("amount", 0.0) if isinstance(val, dict) else val

        expected_val = user_data[month].get(f"expected_{source.lower()}", 0)
        expected_amount = expected_val.get("amount", 0.0) if isinstance(expected_val, dict) else expected_val

        #only be be displayed if one of teh values are different form 0
        if amount != 0 or expected_amount != 0:
            display_sources.append(source)
            actual_income.append(amount)
            expected_income.append(expected_amount)

    if not display_sources:
        st.info("‚ÑπÔ∏è There is no income data to display for this month.")
        return

    # Setup the bar plot
    fig, ax = plt.subplots(figsize=(8, 4))
    bar_width = 0.35
    index = range(len(display_sources))

    bars1 = ax.bar(index, actual_income, bar_width, label="Actual Income", color='lightgreen')
    bars2 = ax.bar([i + bar_width for i in index], expected_income, bar_width, label="Budgeted Income", color='salmon')

    ax.set_xlabel('Income Sources')
    ax.set_ylabel(f"Amount ({currency})")
    ax.set_title(f"Actual vs Budgeted Income - {month.replace('_', ' ').title()}")
    ax.set_xticks([i + bar_width / 2 for i in index])
    ax.set_xticklabels(display_sources, rotation=45, ha='right')
    ax.legend()
    ax.grid(axis='y', linestyle='--', alpha=0.4)

    # Annotate bars with values inside the bars
    for bar in bars1 + bars2:
        height = bar.get_height()
        if height > 0:
            ax.text(bar.get_x() + bar.get_width() / 2, height - (height * 0.05), f'{int(round(height))}',
                    ha='center', va='top', fontsize=8, color='black')

    # automatic scaling and show only integer ticks
    ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x)}'))

    st.pyplot(fig)

#real and budgetd values of expenses
def plot_expenses_vs_budget(month, user_data):
    #check if there is data for the month
    if month not in user_data:
        st.warning("‚ö†Ô∏è No data available for this month.")
        return

    categories = expense_categories
    actual_expenses = []
    expected_expenses = []
    display_categories = []
    currency = st.session_state.get("currency", "EUR")

    #loop through teh categories and get the real and bdugete values 
    for category in categories:
        val = user_data[month].get(category, 0)
        actual_amount = val.get("amount", 0.0) if isinstance(val, dict) else val

        expected = user_data[month].get(f"expected_{category.lower()}", 0)
        expected_amount = expected.get("amount", 0.0) if isinstance(expected, dict) else expected

        # Only include if at least one is different from zero
        if actual_amount != 0 or expected_amount != 0:
            display_categories.append(category)
            actual_expenses.append(actual_amount)
            expected_expenses.append(expected_amount)

    if not display_categories:
        st.info("‚ÑπÔ∏è There are no expenses to display for this month.")
        return

    #graph defenitions
    fig, ax = plt.subplots(figsize=(8, 4))
    bar_width = 0.35
    index = range(len(display_categories))

    bars1 = ax.bar(index, actual_expenses, bar_width, label="Actual Expenses", color='lightblue')
    bars2 = ax.bar([i + bar_width for i in index], expected_expenses, bar_width, label="Budgeted Expenses", color='orange')

    ax.set_xlabel('Categories')
    ax.set_ylabel(f'Amount ({currency})')
    ax.set_title(f"Actual vs Budgeted Expenses for {month.replace('_', ' ').title()}")
    ax.set_xticks([i + bar_width / 2 for i in index])
    ax.set_xticklabels(display_categories, rotation=45, ha='right')
    ax.legend()
    ax.grid(axis='y', linestyle='--', alpha=0.5)

    # Annotate bars with values inside the bars
    for bar in bars1 + bars2:
        yval = bar.get_height()
        if yval > 0:
            ax.text(bar.get_x() + bar.get_width() / 2, yval - (yval * 0.05), f'{int(round(yval))}',
                    ha='center', va='top', fontsize=8, color='black')

    # Y-axis ticks as integers and let the scale adjust automatically
    ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x)}'))

    st.subheader("üíº Real Expenses vs Budget Expenses")
    st.pyplot(fig)


#two months comparision menu
def get_months_to_compare():
    user_data = st.session_state.data.get(st.session_state.username, {})
    
    #chek if tehre is data for the user
    if not user_data:
        st.warning("‚ö†Ô∏è No data available to compare. Please add transactions.")
        return None, None

    # get teh mnths fro the dictionar (need to have two parts, avoid teh currency stored)
    available_keys = [
    k for k in user_data.keys()
    if isinstance(k, str) and "_" in k and len(k.split("_")) == 2 and k.split("_")[1].isdigit()
    ]

    #chekc if there is at least months
    if not available_keys or len(available_keys) < 2:
        st.warning("‚ö†Ô∏è Not enough data to compare. Please add data for at least two months.")
        return None, None

    #make months more readanle
    month_options = [str(k).replace('_', ' ').title() for k in available_keys]

    #layout of month choices
    col1, col2 = st.columns(2)
    with col1:
        month1_display = st.selectbox("üìÖ Select the first month:", month_options, key="compare_month1")
    # Filter out the selected first month from the second list
    filtered_months = [m for m in month_options if m != month1_display]
    with col2:
        month2_display = st.selectbox("üìÖ Select the second month:", filtered_months, key="compare_month2")

    #store months choices
    month1 = available_keys[month_options.index(month1_display)]
    month2 = available_keys[month_options.index(month2_display)]
    return month1, month2

#determine the real total values of income and expnes and the net profit
def get_totals(month, user_data, income_sources, expense_categories):
    income = sum(user_data[month].get(src, {}).get("amount", 0.0) if isinstance(user_data[month].get(src), dict)
                 else user_data[month].get(src, 0.0) for src in income_sources)
    expenses = sum(user_data[month].get(cat, {}).get("amount", 0.0) if isinstance(user_data[month].get(cat), dict)
                   else user_data[month].get(cat, 0.0) for cat in expense_categories)
    return income, expenses, income - expenses

#determine the expected values of incoem and expenes ad net profit
def get_amounts(month, user_data, key, expected_key):
    val = user_data[month].get(key, 0)
    actual = val.get("amount", 0.0) if isinstance(val, dict) else val
    expected_val = user_data[month].get(expected_key, 0)
    expected = expected_val.get("amount", 0.0) if isinstance(expected_val, dict) else expected_val
    return actual, expected

#bar chart comaprison bewten budgetd and real 
def draw_bar_comparison_chart(month1, month2, actual1, expected1, actual2, expected2, title, currency):
    fig, ax = plt.subplots(figsize=(6, 4))
    labels = [month1.replace('_', ' ').title(), month2.replace('_', ' ').title()]
    bar_width = 0.35
    index = range(len(labels))

    bars1 = ax.bar(index, [actual1, actual2], bar_width, label="Actual", color='skyblue')
    bars2 = ax.bar([i + bar_width for i in index], [expected1, expected2], bar_width, label="Budget", color='gray')

    ax.set_title(f"{title} Comparison")
    ax.set_ylabel(f"Amount ({currency})")
    ax.set_xticks([i + bar_width / 2 for i in index])
    ax.set_xticklabels(labels)
    ax.legend()

    for bar in bars1 + bars2:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2, height + 0.5, f'{height:.2f}', ha='center', va='bottom', fontsize=8)

    st.pyplot(fig)

#second 2 monthscomparision menu
def compare_multiple_months():
    month1, month2 = get_months_to_compare()
    #chek if there is teh months were selcted 
    if not month1 or not month2:
        return

    user_data = st.session_state.data[st.session_state.username]
    currency = st.session_state.get("currency", "EUR")

    st.subheader("üîç Select Comparison Type")
    #choices of 2 montsh comparision
    comparison_type = st.radio("Comparison type:", ["Overall Comparison", "Income Comparison", "Expenses Comparison"])

    #overall coparions = net income of 2 months
    if comparison_type == "Overall Comparison":
        income1, expense1, profit1 = get_totals(month1, user_data, income_sources, expense_categories)
        income2, expense2, profit2 = get_totals(month2, user_data, income_sources, expense_categories)

        # table of comaprision
        data = [
            {"Month": month1.replace('_', ' ').title(),
             f"Total Income ({currency})": f"{income1:.2f} ", f"Total Expenses ({currency})": f"{expense1:.2f} ",
             f"Profit ({currency})": f"{profit1:.2f} ",
             "Status": "üü¢ Surplus" if profit1 >= 0 else "üî¥ Deficit"},
            {"Month": month2.replace('_', ' ').title(),
             f"Total Income ({currency})": f"{income2:.2f}", f"Total Expenses ({currency})": f"{expense2:.2f}",
             f"Profit ({currency})": f"{profit2:.2f}",
             "Status": "üü¢ Surplus" if profit2 >= 0 else "üî¥ Deficit"}
        ]

        #verify if there is data for the grapgh 
        if all(v is None or v == 0 for v in [income1, expense1, profit1, income2, expense2, profit2]):
            st.warning("‚ö†Ô∏è No data available for either of the selected months.")
        else:
            st.dataframe(pd.DataFrame(data), use_container_width=True)
            draw_bar_comparison_chart(month1, month2, income1 + expense1, profit1, income2 + expense2, profit2, "Net Results", currency)

    #income comparison of 2 months
    elif comparison_type == "Income Comparison":
        source = st.selectbox("üí∞ Select income source:", income_sources, key="income_source_selector")
        actual1, expected1 = get_amounts(month1, user_data, source, f"expected_{source.lower()}")
        actual2, expected2 = get_amounts(month2, user_data, source, f"expected_{source.lower()}")

        # table of comaprision
        rows = []
        for label, actual, expected in zip([month1, month2], [actual1, actual2], [expected1, expected2]):
            diff = actual - expected
            status = "‚úÖ Over" if diff >= 0 else "‚ùå Under"
            rows.append({
                "Month": label.replace('_', ' ').title(),
                f"Budgeted ({currency})": f"{expected:.2f} ",
                f"Real ({currency})": f"{actual:.2f} ",
                "Status": status
            })

        # verify if there isd data for the grapgh
        if all(v is None or v == 0 for v in [actual1, expected1, actual2, expected2]):
            st.warning("‚ö†Ô∏è No data available for either of the selected months.")
        else:
            st.table(pd.DataFrame(rows))
            draw_bar_comparison_chart(month1, month2, actual1, expected1, actual2, expected2, source, currency)

    #expenses comparison = for 2 months
    elif comparison_type == "Expenses Comparison":
        category = st.selectbox("üí∏ Select expense category:", expense_categories, key="expense_category_selector")
        actual1, expected1 = get_amounts(month1, user_data, category, f"expected_{category.lower()}")
        actual2, expected2 = get_amounts(month2, user_data, category, f"expected_{category.lower()}")

        # table of comaprision
        rows = []
        for label, actual, expected in zip([month1, month2], [actual1, actual2], [expected1, expected2]):
            if actual <= expected:
                status = "‚úÖ Under"
            else:
                status = "‚ùå Over"
            rows.append({
                "Month": label.replace('_', ' ').title(),
                f"Budgeted ({currency})": f"{expected:.2f} ",
                f"Real ({currency})": f"{actual:.2f}",
                "Status": status
            })

        #chekc if tehre is data for teh graph
        if all(v is None or v == 0 for v in [actual1, expected1, actual2, expected2]):
            st.warning("‚ö†Ô∏è No expense data available for the selected category in either month.")
        else:
            st.table(pd.DataFrame(rows))
            draw_bar_comparison_chart(month1, month2, actual1, expected1, actual2, expected2, category, currency)


#VIEW TRANSACTIONS

#get the incoeme transactions
def display_income_transactions(month, data, income_sources):
    total_income = 0
    currency = st.session_state.get("currency", "EUR")

    st.subheader("üí∞ Income Transactions")
    for source in income_sources:
        income_entry = data[month].get(source, 0)
        if isinstance(income_entry, dict):
            amount = income_entry.get("amount", 0)
            description = income_entry.get("description", "")
            if amount > 0:
                total_income += amount
                st.write(f"- *{source}*: {amount:.2f} {currency}" + (f"  \n  Description: {description}" if description else ""))
        elif isinstance(income_entry, (int, float)) and income_entry > 0:
            total_income += income_entry
            st.write(f"- *{source}*: {income_entry:.2f} {currency}")

    return total_income

#get the expenses trasanctions
def display_expense_transactions(month, data, expense_categories):
    total_expense = 0
    currency = st.session_state.get("currency", "EUR")

    st.subheader("üí∏ Expense Transactions")
    for category in expense_categories:
        expense_entry = data[month].get(category, 0)
        if isinstance(expense_entry, dict):
            amount = expense_entry.get("amount", 0)
            description = expense_entry.get("description", "")
            if amount > 0:
                total_expense += amount
                st.write(f"- {category}: {amount:.2f} {currency}" + (f"  \n  Description: {description}" if description else ""))
        elif isinstance(expense_entry, (int, float)) and expense_entry > 0:
            total_expense += expense_entry
            st.write(f"- {category}: {expense_entry:.2f} {currency}")

    return total_expense


def view_transactions():
    st.subheader("üìí Complete Transaction History")
    # Instructions for the user 
    st.markdown(
        "You can view your income and expense transactions for the selected months. "
        "Feel free to select as many months as you wish, and view the data graphically."
    )

    # Check if there is data for the user
    if not st.session_state.get("username"):
        st.warning("‚ö†Ô∏è You must be logged in to view transactions.")
        return

    user_data = st.session_state.data.get(st.session_state.username, {})
    if not user_data:
        st.warning("‚ö†Ô∏è No transaction data available for this user.")
        return

    currency = st.session_state.get("currency", "EUR")

    # Get list of available months and show selection box
    available_months = sorted([
        k for k in user_data.keys()
        if isinstance(k, str) and "_" in k and len(k.split("_")) == 2 and k.split("_")[1].isdigit()
    ])
    # Display months in a readable way
    display_names = [m.replace("_", " ").title() for m in available_months]
    selected_months = st.multiselect("üìÜ Select months to view:", display_names)

    if not selected_months:
        return

    # Store totals for chart and CSV
    chart_data = {"Income": [], "Expenses": []}
    csv_rows = []

    selected_keys = [available_months[display_names.index(name)] for name in selected_months]

    # Loop through selected months
    for i, month_key in enumerate(selected_keys):
        display_name = selected_months[i]
        with st.expander(f"üóìÔ∏è {display_name}"):
            col1, col2, col3 = st.columns([3, 3, 2])

            with col1:
                st.markdown("#### üí∞ Income")
                income_total = display_income_transactions(month_key, user_data, income_sources)  # Your function call

            with col2:
                st.markdown("#### üí∏ Expenses")
                expense_total = display_expense_transactions(month_key, user_data, expense_categories)  # Your function call

            with col3:
                st.markdown("#### üìä Net")
                st.metric("Balance", f"{income_total - expense_total:.2f} {currency}")

            chart_data["Income"].append(income_total)
            chart_data["Expenses"].append(expense_total)

            # For CSV export, accumulate rows per month
            csv_rows.append({
                "Month": display_name,
                "Income": income_total,
                "Expenses": expense_total,
                "Net Balance": income_total - expense_total,
                "Currency": currency
            })

    # Convert CSV rows to DataFrame and CSV string
    df = pd.DataFrame(csv_rows)
    csv_buffer = io.StringIO()
    df.to_csv(csv_buffer, index=False)
    csv_data = csv_buffer.getvalue()

    # Download button for CSV
    st.download_button(
        label="üì• Download Transactions as CSV",
        data=csv_data,
        file_name="transactions.csv",
        mime="text/csv"
    )

    # Add a checkbox for optional chart display
    show_chart = st.checkbox("üìä Show Income and Expense Overview (Graph)", value=True)

    if show_chart and chart_data["Income"]:
        st.subheader("üìä Income and Expense Overview")

        # Dropdown menu for chart display preference
        chart_option = st.selectbox(
            "üìà Choose what to display:",
            ["Income vs Expenses", "Only Income", "Only Expenses"]
        )

        # Chart configuration
        x = np.arange(len(selected_months))
        width = 0.35
        income_vals = chart_data["Income"]
        expense_vals = chart_data["Expenses"]

        fig, ax = plt.subplots()

        # Function to annotate bars with values
        def annotate_bars(bars):
            for bar in bars:
                height = bar.get_height()
                ax.annotate(f'{height:.2f}', xy=(bar.get_x() + bar.get_width() / 2, height),
                            xytext=(0, 3), textcoords="offset points",
                            ha='center', va='bottom', fontsize=8)

        if chart_option == "Income vs Expenses":
            bars1 = ax.bar(x - width/2, income_vals, width, label='Income', color='lightgreen')
            bars2 = ax.bar(x + width/2, expense_vals, width, label='Expenses', color='salmon')
            annotate_bars(bars1 + bars2)

        elif chart_option == "Only Income":
            bars = ax.bar(x, income_vals, width, label='Income', color='lightgreen')
            annotate_bars(bars)

        elif chart_option == "Only Expenses":
            bars = ax.bar(x, expense_vals, width, label='Expenses', color='salmon')
            annotate_bars(bars)

        ax.set_ylabel(f'Amount ({currency})')
        ax.set_title(chart_option)
        ax.set_xticks(x)
        ax.set_xticklabels(selected_months, rotation=45)
        ax.legend()
        plt.tight_layout()
        st.pyplot(fig)


#LOGOUT AND MENU!!

def logout():
    st.session_state.username = None
    save_data()
    st.success("You have been logged out.")
    st.rerun()

#MAIN DASHBOARD

def dashboard():
    # Sidebar welcome
    st.sidebar.markdown("#### üìù Welcome to Budget Friend")

    # Get current username
    username = st.session_state.username

    # Ensure user data exists
    if username not in st.session_state.data:
        st.session_state.data[username] = {}

    user_data = st.session_state.data[username]

    # Get supported currencies
    currencies = get_supported_currencies()

    # Load saved currency or set default
    saved_currency = user_data.get("currency", "EUR")

    # Show currency selector with default set to saved one
    selected_currency = st.sidebar.selectbox(
        "üí± Select a Currency:",
        options=list(currencies.keys()),
        index=list(currencies.keys()).index(saved_currency)
    )

    # Update session and user data
    st.session_state.currency = selected_currency
    st.session_state.data[username]["currency"] = selected_currency
    save_data()

    # Show selected currency
    st.sidebar.markdown(f"**Selected:** {selected_currency} ({currencies[selected_currency]})")

    # Menu options
    menu_options = {
        "üè† Main Page": "main",
        "üßæ Define Budget": "define",
        "üí∞ Add Income": "income",
        "üí∏ Add Expenses": "expense",
        "üìä View Summary": "summary",
        "üìã View Transactions": "transactions"
    }

    choice = st.sidebar.radio("üìÇ Menu", list(menu_options.keys()))

    # Logout
    st.sidebar.markdown("---")
    if st.sidebar.button("üö™ Logout"):
        logout()
        return

    # Main content
    if menu_options[choice] == "main":
        col1, col2 = st.columns([1, 2])
        with col1:
            st.image(
                'https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExZDVxcnZ4ZmE0ZGxuMm5iOWUwamhlOTBzYjNtaThqdmp3bjQ2NnZldSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/cJFQJzZxFMhONxDTnt/giphy.gif',
                caption='Track your finances with ease!',
                use_container_width=True
            )
        with col2:
            st.subheader("Welcome to Budget Friend!")
            st.write("""
                **Your Personal Finance Tracker**

                Budget Friend is here to help you manage your finances with ease. Whether you're saving for a goal, tracking spending, or setting budgets, this tool has you covered.

                Here's what you can do with Budget Friend:
                - **Define and Manage Budgets**: Set budgets for different categories like rent, food, entertainment, and more.
                - **Track Income and Expenses**: Add your income sources and track your spending to stay within your budget.
                - **Monitor Monthly Spending**: See at a glance how much you've spent in each category and track your monthly expenses.
                - **View Detailed Summaries**: Access easy-to-read reports with a breakdown of all your transactions and financial health.
            """)
            st.info("Navigate through the menu on the left to get started with your budgeting journey!")

    elif menu_options[choice] == "define":
        define_budget()
    elif menu_options[choice] == "income":
        add_income()
    elif menu_options[choice] == "expense":
        add_expense()
    elif menu_options[choice] == "summary":
        view_summary()
    elif menu_options[choice] == "transactions":
        view_transactions()


if __name__ == "__main__":
    # Check if the user is logged in, otherwise show login/create account options
    if st.session_state.username is None:
        action = st.radio("Choose an action", ["Login", "Create Account"])
        if action == "Login":
            login()
        elif action == "Create Account":
            create_account()
    else:
        load_data()  # Load user data if logged in
        dashboard()  # Show the dashboard if logged in
